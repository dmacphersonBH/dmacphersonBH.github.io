<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Interactive Quilt Block Designer</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.9.3/p5.js"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&display=swap');
        body {
            font-family: 'Inter', sans-serif;
            background-color: #f7f7f7;
            /* NEW: Use Flexbox on the body to center the content */
            display: flex;
            justify-content: center; /* Center horizontally */
            align-items: flex-start; /* Align to the top, but allow vertical scrolling */
            min-height: 100vh;
            padding: 1rem;
            margin: 0; /* Ensure no default body margins interfere */
            /* Allow horizontal scrolling on the body if content expands past viewport */
            overflow-x: auto; 
            overflow-y: auto;
        }
        
        /* NEW: Wrapper to hold the content centered, necessary since the inner div is no longer fixed width */
        #app-center-wrapper {
             /* Ensures the wrapper takes up the minimum space needed to contain the centered content */
             display: inline-block; 
        }

        /* The main quilt container is now a flex column, allowing it to expand horizontally */
        #quiltArea {
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 1rem;
            /* Remove overflow constraints to allow horizontal expansion */
            overflow: visible; 
        }

        /* The canvas itself */
        canvas {
            border: 4px solid #2d3748; /* Dark gray border */
            border-radius: 0.5rem;
            box-shadow: 0 10px 15px rgba(0, 0, 0, 0.2);
            touch-action: none; /* Prevent scrolling on touch devices while dragging */
        }
        .color-option.selected {
            outline: 4px solid #3b82f6; /* Blue ring */
            outline-offset: 2px;
        }
        
        /* Control Button Styling */
        .grid-btn {
            @apply bg-blue-600 text-white font-extrabold shadow-lg hover:bg-blue-700 transition duration-150 active:scale-95 disabled:bg-gray-400 disabled:cursor-not-allowed;
            border-radius: 9999px; 
            width: 44px; 
            height: 44px; 
            font-size: 24px;
            line-height: 1; 
            justify-content: center;
            align-items: center;
        }
        .grid-control-wrapper {
            width: 30; 
            height: 30;
            background-color: #e5e7eb; /* gray-200 */
            border-radius: 9999px; 
            display: flex;
            justify-content: center;
            align-items: center;
            box-shadow: inset 0 2px 4px rgba(0, 0, 0, 0.1);
        }
        
        /* Styling for the vertical (LEFT/RIGHT) controls container */
       

        /* Grid Layout for the Interactive Area (Canvas + Controls) */
        #quiltGridContainer {
            display: grid;
            /* 3 Columns: Left Controls | Canvas | Right Controls */
            grid-template-columns: auto 1fr auto; 
            /* 3 Rows: Top Controls | Canvas Row | Bottom Controls */
            grid-template-rows: auto 1fr auto; 
            justify-items: center; 
            align-items: center; 
            /* This inline-block ensures the grid container itself centers correctly 
               and only takes up the space needed by the content */
            display: inline-grid;
        }

        /* Assigning grid areas */
        #topRowControls { grid-column: 2 / 3; grid-row: 1 / 2; width: 100%; display: flex; justify-content: space-around; padding: 1rem 0;}
        #bottomRowControls { grid-column: 2 / 3; grid-row: 3 / 4; width: 100%; display: flex; justify-content: space-around; padding: 1rem 0;}

        #leftColControls { grid-column: 1 / 2; grid-row: 2 / 3; }
        #rightColControls { grid-column: 3 / 4; grid-row: 2 / 3; }

        #p5Canvas { grid-column: 2 / 3; grid-row: 2 / 3; }

        /* Hide the vertical labels */
        .rotated-text {
            display: none;
        }
    </style>
</head>
<body class="bg-gray-100">

    <div id="app-center-wrapper">
        <div class="mx-auto flex flex-col lg:flex-row gap-8 bg-white p-6 rounded-xl shadow-2xl">
            
            <div class="lg:w-1/3 space-y-6 min-w-[300px]"> <h1 class="text-3xl font-bold text-gray-800 border-b pb-2">Quilt Block Designer</h1>
                <p class="text-sm text-gray-600">
                    Left-click to draw</br> Right-click to erase </br> Number keys to select active colour
                  
                </p>
                <div class="space-y-1">
                     <p class="font-semibold text-gray-700">Current Grid Size:</p>
                     <div class="flex space-x-4">
                         <span class="text-lg font-bold text-blue-600">ROWS: <span id="rowCountDisplay">8</span></span>
                         <span class="text-lg font-bold text-blue-600">COLS: <span id="colCountDisplay">8</span></span>
                     </div>
                </div>

                <div class="rounded-lg p-4 bg-blue-50 border border-blue-200">
                    <p class="font-semibold text-blue-700">Current Selection:</p>
                    <div id="currentSelection" class="flex items-center mt-2 space-x-2">
                        </div>
                </div>

                <div class="space-y-2 pt-4 border-t border-gray-200">
                    <h2 class="text-xl font-semibold text-gray-700">Select Color (1-10)</h2>
                    <div id="colorPalette" class="flex flex-wrap gap-2">
                        </div>
                </div>

                <div class="space-y-2 pt-4 border-t border-gray-200">
                    <h2 class="text-xl font-semibold text-gray-700">Customize Palette</h2>
                    <div id="colorEditor" class="grid grid-cols-5 gap-2">
                        </div>
                    <p class="text-xs text-gray-500 pt-2">Your custom colors are saved automatically.</p>
                </div>
                
                <button id="clearAll" class="w-full bg-red-500 hover:bg-red-600 text-white font-bold py-2 px-4 rounded-lg transition mt-8">
                    Clear All Triangles
                </button>
                
                <div class="pt-4 border-t border-gray-200 space-y-2">
                    <h2 class="text-xl font-semibold text-gray-700">Export Design</h2>
                    <div class="flex space-x-2">
                        <button id="exportPNG" class="flex-1 bg-green-500 hover:bg-green-600 text-white font-bold py-2 px-4 rounded-lg transition">
                            Export PNG
                        </button>
                        <button id="exportSVG" class="flex-1 bg-purple-500 hover:bg-purple-600 text-white font-bold py-2 px-4 rounded-lg transition">
                            Export SVG
                        </button>
                    </div>
                </div>
            </div>

            <div class="p-4 flex justify-center" id="quiltArea">

                <div id="quiltGridContainer">
                    
                    <div id="topRowControls" class="">
                        <div class="flex items-center space-x-4">
                      
                            <div class="grid-control-wrapper"><button id="removeRowTop" class="grid-btn">-</button></div>
                            <div class="grid-control-wrapper"><button id="addRowTop" class="grid-btn">+</button></div>
                        </div>
                    </div>

                    <div id="leftColControls" class="v-controls-container mr-4">
                 
                        <div class="grid-control-wrapper"><button id="removeColLeft" class="grid-btn">-</button></div>
                        <div class="my-[40px]"></div> <div class="grid-control-wrapper"><button id="addColLeft" class="grid-btn">+</button></div>
                    </div>

                    <div id="p5Canvas" class="shadow-xl">
                        </div>

                    <div id="rightColControls" class="v-controls-container ml-4">
                        <div class="grid-control-wrapper"><button id="addRowRight" class="grid-btn">+</button></div>
                        <div class="my-[40px]"></div> <div class="grid-control-wrapper"><button id="removeRowRight" class="grid-btn">-</button></div>
                    </div>
                    
                    <div id="bottomRowControls" class="">
                        <div class="flex items-center space-x-4">
                        
                            <div class="grid-control-wrapper"><button id="removeRowBottom" class="grid-btn">-</button></div>
                            <div class="grid-control-wrapper"><button id="addRowBottom" class="grid-btn">+</button></div>
                        </div>
                    </div>

                </div>
                
            </div>
        </div>
    </div> <script type="module">
        // --- Firebase Imports ---
        import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
        import { getAuth, signInAnonymously, signInWithCustomToken } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";
        import { getFirestore, doc, getDoc, setDoc } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";
        
        // --- Firebase Globals & Configuration ---
        let db;
        let auth;
        let userId = 'anonymous'; 
        let isPaletteLoaded = false;
        
        const appId = typeof __app_id !== 'undefined' ? __app_id : 'default-app-id';
        const firebaseConfig = typeof __firebase_config !== 'undefined' ? JSON.parse(__firebase_config) : {};
        const initialAuthToken = typeof __initial_auth_token !== 'undefined' ? __initial_auth_token : null;
        
        // --- Quilt Block Globals ---
        let ROWS = 8;
        let COLS = 8;
        const MIN_GRID = 4;
        const MAX_GRID = 24; // Increased max grid size to 24x24
        // The fixed pixel size for each cell (square). Canvas size will grow/shrink.
        const CELL_SIZE = 70; 

        const PALETTE_DEFAULTS = [
            '#ffffff', // Index 0: White (Clear/Erase color)
            '#003f5c', // 1. Navy Blue
            '#58508d', // 2. Purple
            '#bc5090', // 3. Pink
            '#ff6361', // 4. Red/Coral
            '#ffa600', // 5. Orange
            '#488f31', // 6. Forest Green
            '#d4edda', // 7. Light Mint
            '#00a896', // 8. Teal
            '#70c1b3', // 9. Dusty Blue
            '#ff5722', // 10. Deep Orange
        ];

        let PALETTE = [...PALETTE_DEFAULTS]; // Customizable palette
        let blockGrid = []; 
        let currentColorIndex = 1; 

        // --- Firebase Persistence Functions ---

        /** Gets the document reference for the user's saved palette. */
        const getPaletteDocRef = (uid) => {
            const path = `/artifacts/${appId}/users/${uid}/settings`;
            return doc(db, path, 'palette');
        };

        /** Saves the current custom colors (indices 1-10) to Firestore. */
        const savePalette = async () => {
            if (!db || userId === 'anonymous') return;
            const customColors = PALETTE.slice(1);
            
            try {
                const paletteRef = getPaletteDocRef(userId);
                await setDoc(paletteRef, { customColors: customColors }, { merge: true });
            } catch (error) {
                console.error("Error saving palette to Firestore:", error);
            }
        };

        /** Loads the custom colors from Firestore, or uses defaults. */
        const loadPalette = async () => {
            try {
                const paletteRef = getPaletteDocRef(userId);
                const docSnap = await getDoc(paletteRef);

                if (docSnap.exists()) {
                    const savedData = docSnap.data();
                    const savedColors = savedData.customColors;
                    // Check if saved array is valid (10 colors)
                    if (Array.isArray(savedColors) && savedColors.length === PALETTE_DEFAULTS.length - 1) {
                        // Reconstruct the PALETTE: White (index 0) + custom colors (indices 1-10)
                        PALETTE = [PALETTE_DEFAULTS[0], ...savedColors];
                    }
                } else {
                    // Save defaults if no document exists
                    await savePalette();
                }
            } catch (error) {
                console.error("Error loading palette from Firestore. Using defaults.", error);
            } finally {
                isPaletteLoaded = true;
                // Once loaded, set up controls and refresh canvas
                setupControls(); 
                updateSelectionDisplay();
                updateGridDisplay(); // Initial grid display setup
                if (window.draw) window.draw(); 
            }
        };
        
        /** Asynchronously sets up Firebase authentication and Firestore. */
        const setupFirebase = async () => {
            try {
                const app = initializeApp(firebaseConfig);
                db = getFirestore(app);
                auth = getAuth(app);
                
                // Authenticate
                if (initialAuthToken) {
                    await signInWithCustomToken(auth, initialAuthToken);
                } else {
                    await signInAnonymously(auth);
                }

                if (auth.currentUser) {
                    userId = auth.currentUser.uid;
                } else {
                    userId = crypto.randomUUID(); 
                }
                
                // Load palette which handles calling setupControls and draw
                await loadPalette();

            } catch (error) {
                console.error("Firebase initialization failed:", error);
                // Fallback: If Firebase fails, still set up controls with defaults
                setupControls();
                isPaletteLoaded = true;
                updateSelectionDisplay();
                updateGridDisplay();
            }
        };


        // --- P5.JS SETUP AND DRAW FUNCTIONS ---
        
        /** Recalculates canvas size and updates HTML/CSS wrappers for a fixed cell size model. */
        const updateCanvasAndWrapperSizes = (newWidth, newHeight) => {
            if (window.width !== newWidth || window.height !== newHeight) {
                // Resize the p5.js canvas
                resizeCanvas(newWidth, newHeight);
            }

            // Update the HTML container (#p5Canvas) to ensure proper layout
            const p5CanvasWrapper = document.getElementById('p5Canvas');
            p5CanvasWrapper.style.width = `${newWidth}px`;
            p5CanvasWrapper.style.height = `${newHeight}px`;
        };
        
        window.setup = () => {
            // Calculate initial canvas size based on fixed CELL_SIZE
            const initialWidth = COLS * CELL_SIZE;
            const initialHeight = ROWS * CELL_SIZE;

            const canvas = createCanvas(initialWidth, initialHeight);
            canvas.parent('p5Canvas');
            initializeGrid();
            noStroke();
            
            // Set the initial size of the wrappers
            updateCanvasAndWrapperSizes(initialWidth, initialHeight);

            // Start Firebase setup and palette loading
            setupFirebase();
        };

        window.draw = () => {
            // Only draw the grid once the palette is guaranteed to be loaded/defaulted
            if (isPaletteLoaded) {
                background(255);
                drawGrid();
            }
        };

        /** Handles number key presses to change the selected color (1-10). */
        window.keyPressed = () => {
            let keyAsNum;
            if (key === '0') {
                keyAsNum = 10;
            } else {
                keyAsNum = parseInt(key);
            }

            if (!isNaN(keyAsNum) && keyAsNum >= 1 && keyAsNum <= PALETTE.length - 1) {
                currentColorIndex = keyAsNum;
                updateSelectionDisplay();
                return false; 
            }
        }

        // --- HELPER FUNCTIONS ---

        const createEmptyCell = () => ({ top: 0, right: 0, bottom: 0, left: 0 });

        /** Initializes the grid with default white QSTs. */
        const initializeGrid = () => {
            blockGrid = [];
            for (let i = 0; i < ROWS; i++) {
                blockGrid[i] = [];
                for (let j = 0; j < COLS; j++) {
                    blockGrid[i][j] = createEmptyCell();
                }
            }
        };

        /** Draws the quilt block based on the current blockGrid state (now QSTs). */
        const drawGrid = (isSVG = false) => {
            const size = CELL_SIZE; 
            const svgElements = [];
            
            // Define colors and strokes for P5.js vs SVG
            const strokeColor = isSVG ? '#323232' : 'rgb(50, 50)';
            const gridColor = isSVG ? 'none' : 'rgb(255)';

            if (!isSVG) {
                background(255); // Only set background in P5.js draw loop
                noStroke(); // Reset for triangle fills
            }


            for (let i = 0; i < ROWS; i++) {
                for (let j = 0; j < COLS; j++) {
                    const x = j * size;
                    const y = i * size;
                    // Check if cell exists (should always exist if logic is sound)
                    if (!blockGrid[i] || !blockGrid[i][j]) continue; 

                    const cell = blockGrid[i][j];
                    
                    const cx = x + size / 2;
                    const cy = y + size / 2;
                    
                    // Quilt Square Triangle (QST) coordinates
                    const triangles = [
                        // 1. Top QST (Top-Left, Top-Right, Center)
                        { key: 'top', color: PALETTE[cell.top], points: [x, y, x + size, y, cx, cy] },
                        // 2. Right QST (Top-Right, Bottom-Right, Center)
                        { key: 'right', color: PALETTE[cell.right], points: [x + size, y, x + size, y + size, cx, cy] },
                        // 3. Bottom QST (Bottom-Right, Bottom-Left, Center)
                        { key: 'bottom', color: PALETTE[cell.bottom], points: [x + size, y + size, x, y + size, cx, cy] },
                        // 4. Left QST (Bottom-Left, Top-Left, Center)
                        { key: 'left', color: PALETTE[cell.left], points: [x, y + size, x, y, cx, cy] }
                    ];

                    triangles.forEach(t => {
                        const [x1, y1, x2, y2, x3, y3] = t.points;
                        const fillColor = t.color;

                        if (isSVG) {
                            // SVG polygon element string
                            const pointsString = `${x1},${y1} ${x2},${y2} ${x3},${y3}`;
                            svgElements.push(`<polygon points="${pointsString}" fill="${fillColor}" stroke="${strokeColor}" stroke-width="0.5"/>`);
                        } else {
                            // P5.js rendering
                            fill(fillColor);
                            triangle(x1, y1, x2, y2, x3, y3);
                        }
                    });

                    if (!isSVG) {
                        // Add grid lines for visibility in p5.js
                        stroke(50, 50);
                        strokeWeight(1);
                        // Cell boundaries
                        line(x + size, y, x + size, y + size);
                        line(x, y + size, x + size, y + size);

                        // Draw the internal QST lines (diagonals)
                        stroke(50, 50);
                        line(x, y, x + size, y + size); // Main diagonal
                        line(x + size, y, x, y + size); // Anti-diagonal
                        
                        noStroke();
                    }
                }
            }
            
            if (isSVG) {
                // Return the array of SVG elements for the exporter
                return svgElements.join('\n');
            }
        };

        /** Applies the current action (paint or clear) to the specific QST triangle at coordinates (x, y). */
        window.applyPatternAt = (x, y) => {
            if (x >= 0 && x < width && y >= 0 && y < height) {
                const size = CELL_SIZE;

                const col = floor(x / size);
                const row = floor(y / size);

                if (row >= 0 && row < ROWS && col >= 0 && col < COLS) {
                    
                    const rx = x - col * size; // Relative X within the cell
                    const ry = y - row * size; // Relative Y within the cell
                    
                    let triangleKey = null;

                    // Click detection based on QST geometry (from cell center to corners)
                    const isBelowMainDiagonal = ry > rx; 
                    const isBelowAntiDiagonal = ry > size - rx; 

                    // Quadrant/Triangle logic based on diagonals:
                    // Top: Below Main (false) AND Below Anti (false)
                    // Left: Below Main (true) AND Below Anti (false)
                    // Bottom: Below Main (true) AND Below Anti (true)
                    // Right: Below Main (false) AND Below Anti (true) - Note: Corrected logic from original code.

                    if (ry <= rx && ry <= size - rx) { // Top
                        triangleKey = 'top';
                    } else if (ry > rx && ry <= size - rx) { // Left
                        triangleKey = 'left';
                    } else if (ry > rx && ry > size - rx) { // Bottom
                        triangleKey = 'bottom';
                    } else if (ry <= rx && ry > size - rx) { // Right
                         triangleKey = 'right';
                    }
                    
                    let colorIndex;
                    // Right-click uses color index 0 (white/erase)
                    if (mouseButton === RIGHT) {
                        colorIndex = 0; 
                    } else {
                        colorIndex = currentColorIndex;
                    }

                    if (triangleKey && blockGrid[row][col][triangleKey] !== colorIndex) {
                        blockGrid[row][col][triangleKey] = colorIndex;
                        window.draw(); // Redraw immediately on change
                    }
                }
            }
        };

        /** Handles the initial mouse click (for single triangle placement). */
        window.mousePressed = () => {
            applyPatternAt(mouseX, mouseY);
            return false; 
        };

        /** Handles mouse drag (for filling multiple triangles). */
        window.mouseDragged = () => {
            applyPatternAt(mouseX, mouseY);
            return false; 
        }

        /** Disables the context menu (right-click menu) to allow for right-click clearing. */
        document.addEventListener('contextmenu', event => event.preventDefault());
        
        // --- GRID ADJUSTMENT FUNCTIONS ---

        /** Updates the display text for row and column counts and manages button disabled state. */
        const updateGridDisplay = () => {
            // Update counts in the left panel
            document.getElementById('rowCountDisplay').textContent = ROWS;
            document.getElementById('colCountDisplay').textContent = COLS;

            // Manage button states (ROWS)
            const rowButtons = ['addRowTop', 'removeRowTop', 'addRowBottom', 'removeRowBottom'];
            rowButtons.forEach(id => {
                const btn = document.getElementById(id);
                if (btn) btn.disabled = (ROWS >= MAX_GRID && id.startsWith('add')) || (ROWS <= MIN_GRID && id.startsWith('remove'));
            });

            // Manage button states (COLS)
            const colButtons = ['addColLeft', 'removeColLeft', 'addRowRight', 'removeRowRight']; // RowRight buttons correspond to ColRight operations
            colButtons.forEach(id => {
                 const btn = document.getElementById(id);
                if (btn) btn.disabled = (COLS >= MAX_GRID && id.startsWith('add')) || (COLS <= MIN_GRID && id.startsWith('remove'));
            });
        };
        
        // Adjusts the number of rows from the TOP (uses unshift/shift)
        const adjustRowsTop = (delta) => {
            const newRows = ROWS + delta;
            if (newRows < MIN_GRID || newRows > MAX_GRID) return;

            if (delta > 0) {
                // Add new row to the top
                blockGrid.unshift(Array.from({ length: COLS }, createEmptyCell));
            } else if (delta < 0) {
                // Remove row from the top
                blockGrid.shift(); 
            }
            ROWS = newRows;
            
            // Recalculate and resize the canvas and wrappers
            updateCanvasAndWrapperSizes(COLS * CELL_SIZE, ROWS * CELL_SIZE);
            updateGridDisplay();
            window.draw();
        };

        // Adjusts the number of rows from the BOTTOM (uses push/pop)
        const adjustRowsBottom = (delta) => {
            const newRows = ROWS + delta;
            if (newRows < MIN_GRID || newRows > MAX_GRID) return;

            if (delta > 0) {
                // Add new row to the bottom
                blockGrid.push(Array.from({ length: COLS }, createEmptyCell));
            } else if (delta < 0) {
                // Remove row from the bottom
                blockGrid.pop(); 
            }
            ROWS = newRows;
            
            // Recalculate and resize the canvas and wrappers
            updateCanvasAndWrapperSizes(COLS * CELL_SIZE, ROWS * CELL_SIZE);
            updateGridDisplay();
            window.draw();
        };

        // Adjusts the number of columns from the LEFT (uses unshift/shift on each row)
        const adjustColsLeft = (delta) => {
            const newCols = COLS + delta;
            if (newCols < MIN_GRID || newCols > MAX_GRID) return;

            blockGrid.forEach(row => {
                if (delta > 0) {
                    // Add new column to the left (unshift)
                    row.unshift(createEmptyCell());
                } else if (delta < 0) {
                    // Remove column from the left (shift)
                    row.shift(); 
                }
            });
            COLS = newCols;

            // Recalculate and resize the canvas and wrappers
            updateCanvasAndWrapperSizes(COLS * CELL_SIZE, ROWS * CELL_SIZE);
            updateGridDisplay();
            window.draw();
        };
        
        // Adjusts the number of columns from the RIGHT (uses push/pop on each row)
        const adjustColsRight = (delta) => {
            const newCols = COLS + delta;
            if (newCols < MIN_GRID || newCols > MAX_GRID) return;

            blockGrid.forEach(row => {
                if (delta > 0) {
                    // Add new column to the right (push)
                    row.push(createEmptyCell());
                } else if (delta < 0) {
                    // Remove column from the right (pop)
                    row.pop(); 
                }
            });
            COLS = newCols;

            // Recalculate and resize the canvas and wrappers
            updateCanvasAndWrapperSizes(COLS * CELL_SIZE, ROWS * CELL_SIZE);
            updateGridDisplay();
            window.draw();
        };


        // --- EXPORT FUNCTIONS ---
        
        /** Exports the canvas content as a PNG file using p5.js saveCanvas. */
        const exportPNG = () => {
             saveCanvas('quilt_design', 'png');
        };
        
        /** Exports the quilt design as an SVG file by generating the SVG content string. */
        const exportSVG = () => {
            const width = COLS * CELL_SIZE;
            const height = ROWS * CELL_SIZE;
            
            // 1. Generate the SVG polygon elements
            const svgContent = drawGrid(true); // Pass true to activate SVG-mode rendering

            // 2. Wrap the content in the SVG structure
            const svgText = `
                <svg width="${width}" height="${height}" viewBox="0 0 ${width} ${height}" xmlns="http://www.w3.org/2000/svg">
                    <rect width="100%" height="100%" fill="#ffffff"/>
                    <g stroke="#323232" stroke-width="0.5">
                        ${svgContent}
                    </g>
                </svg>
            `.trim();
            
            // 3. Create a Blob and trigger download
            const blob = new Blob([svgText], {type: 'image/svg+xml;charset=utf-8'});
            const url = URL.createObjectURL(blob);
            
            const a = document.createElement('a');
            a.href = url;
            a.download = 'quilt_design.svg';
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
        };

        // --- UI CONTROL FUNCTIONS ---

        /** Updates the small preview box with the current selection */
        const updateSelectionDisplay = () => {
            const display = document.getElementById('currentSelection');
            const selectedColor = PALETTE[currentColorIndex];
            
            const colorPreview = `<span class="h-6 w-6 rounded-full border-2 border-white shadow-md" style="background-color: ${selectedColor}"></span>`;
            
            const keyDisplay = currentColorIndex === 10 ? '0' : currentColorIndex;
            const colorText = `${selectedColor} (Key ${keyDisplay})`;
            
            display.innerHTML = `
                ${colorPreview}
                <span class="font-bold text-gray-800">${colorText}</span>
            `;

            // Update color buttons state
            document.querySelectorAll('.color-option').forEach((btn) => {
                const btnIndex = parseInt(btn.dataset.colorIndex);
                if (btnIndex === currentColorIndex) {
                    btn.classList.add('selected');
                } else {
                    btn.classList.remove('selected');
                }
            });
        };

        /** Sets up event listeners for color controls, and utility buttons. */
        const setupControls = () => {
            const paletteDiv = document.getElementById('colorPalette');
            const editorDiv = document.getElementById('colorEditor');
            
            paletteDiv.innerHTML = '';
            editorDiv.innerHTML = '';
            
            // 1. Color Palette Selector Setup and Custom Color Input Setup
            PALETTE.forEach((color, index) => {
                if (index === 0) return; // Skip white (index 0)

                const keyDisplay = index === 10 ? '0' : index; // '0' for index 10

                // --- Selector Button ---
                const btn = document.createElement('button');
                btn.className = `color-option h-8 w-8 rounded-full cursor-pointer transition transform hover:scale-110 border-2 border-white shadow-md text-xs font-bold flex items-center justify-center relative`; 
                btn.style.backgroundColor = color;
                btn.dataset.colorIndex = index;
                btn.title = `Select Color ${index} (Key ${keyDisplay})`;

                const label = document.createElement('span');
                label.className = `text-white drop-shadow-sm pointer-events-none`; 
                label.textContent = keyDisplay;
                
                btn.appendChild(label); 

                btn.addEventListener('click', () => {
                    currentColorIndex = index;
                    updateSelectionDisplay();
                });
                paletteDiv.appendChild(btn);

                // --- Custom Color Input ---
                const editorInput = document.createElement('input');
                editorInput.type = 'color';
                editorInput.value = color;
                editorInput.dataset.colorIndex = index;
                editorInput.className = "w-full h-10 rounded-lg cursor-pointer border-2 border-gray-300 transition hover:shadow-lg";
                editorInput.title = `Edit Color ${index}`;

                editorInput.addEventListener('change', (e) => {
                    const newColor = e.target.value;
                    const colorIndex = parseInt(e.target.dataset.colorIndex);
                    
                    PALETTE[colorIndex] = newColor;
                    
                    const selectButton = document.querySelector(`.color-option[data-color-index="${colorIndex}"]`);
                    if (selectButton) {
                        selectButton.style.backgroundColor = newColor;
                    }

                    if (currentColorIndex === colorIndex) {
                        updateSelectionDisplay();
                    }
                    window.draw(); 
                    savePalette();
                });
                editorDiv.appendChild(editorInput);
            });

            // Set initial selected state
            const initialSelectionBtn = document.querySelector(`.color-option[data-color-index="${currentColorIndex}"]`);
            if (initialSelectionBtn) {
                initialSelectionBtn.classList.add('selected');
            }
            
            // 2. Clear All Button
            document.getElementById('clearAll').addEventListener('click', () => {
                initializeGrid();
                window.draw();
            });
            
            // 3. Grid Controls Setup
            // Rows
            document.getElementById('addRowTop').addEventListener('click', () => adjustRowsTop(1));
            document.getElementById('removeRowTop').addEventListener('click', () => adjustRowsTop(-1));
            document.getElementById('addRowBottom').addEventListener('click', () => adjustRowsBottom(1));
            document.getElementById('removeRowBottom').addEventListener('click', () => adjustRowsBottom(-1));

            // Columns (Right buttons perform 'Right' adjustments, Left buttons perform 'Left' adjustments)
            document.getElementById('addRowRight').addEventListener('click', () => adjustColsRight(1));
            document.getElementById('removeRowRight').addEventListener('click', () => adjustColsRight(-1));
            document.getElementById('addColLeft').addEventListener('click', () => adjustColsLeft(1));
            document.getElementById('removeColLeft').addEventListener('click', () => adjustColsLeft(-1));
            
            // 4. Export Controls Setup
            document.getElementById('exportPNG').addEventListener('click', exportPNG);
            document.getElementById('exportSVG').addEventListener('click', exportSVG);
        };

    </script>
</body>
</html>